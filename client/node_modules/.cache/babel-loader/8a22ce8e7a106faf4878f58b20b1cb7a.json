{"ast":null,"code":"/*!\n * base64id v0.1.0\n */\n\n/**\n * Module dependencies\n */\nvar crypto = require('crypto');\n/**\n * Constructor\n */\n\n\nvar Base64Id = function () {};\n/**\n * Get random bytes\n *\n * Uses a buffer if available, falls back to crypto.randomBytes\n */\n\n\nBase64Id.prototype.getRandomBytes = function (bytes) {\n  var BUFFER_SIZE = 4096;\n  var self = this;\n  bytes = bytes || 12;\n\n  if (bytes > BUFFER_SIZE) {\n    return crypto.randomBytes(bytes);\n  }\n\n  var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);\n  var threshold = parseInt(bytesInBuffer * 0.85);\n\n  if (!threshold) {\n    return crypto.randomBytes(bytes);\n  }\n\n  if (this.bytesBufferIndex == null) {\n    this.bytesBufferIndex = -1;\n  }\n\n  if (this.bytesBufferIndex == bytesInBuffer) {\n    this.bytesBuffer = null;\n    this.bytesBufferIndex = -1;\n  } // No buffered bytes available or index above threshold\n\n\n  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {\n    if (!this.isGeneratingBytes) {\n      this.isGeneratingBytes = true;\n      crypto.randomBytes(BUFFER_SIZE, function (err, bytes) {\n        self.bytesBuffer = bytes;\n        self.bytesBufferIndex = 0;\n        self.isGeneratingBytes = false;\n      });\n    } // Fall back to sync call when no buffered bytes are available\n\n\n    if (this.bytesBufferIndex == -1) {\n      return crypto.randomBytes(bytes);\n    }\n  }\n\n  var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));\n  this.bytesBufferIndex++;\n  return result;\n};\n/**\n * Generates a base64 id\n *\n * (Original version from socket.io <http://socket.io>)\n */\n\n\nBase64Id.prototype.generateId = function () {\n  var rand = Buffer.alloc(15); // multiple of 3 for base64\n\n  if (!rand.writeInt32BE) {\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n  }\n\n  this.sequenceNumber = this.sequenceNumber + 1 | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n\n  if (crypto.randomBytes) {\n    this.getRandomBytes(12).copy(rand);\n  } else {\n    // not secure for node 0.4\n    [0, 4, 8].forEach(function (i) {\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\n    });\n  }\n\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n/**\n * Export\n */\n\n\nexports = module.exports = new Base64Id();","map":{"version":3,"sources":["/Users/obscurax/Documents/Études/Applications Web/react-gambling-project/node_modules/base64id/lib/base64id.js"],"names":["crypto","require","Base64Id","prototype","getRandomBytes","bytes","BUFFER_SIZE","self","randomBytes","bytesInBuffer","parseInt","threshold","bytesBufferIndex","bytesBuffer","isGeneratingBytes","err","result","slice","generateId","rand","Buffer","alloc","writeInt32BE","Math","abs","random","Date","now","toString","sequenceNumber","copy","forEach","i","pow","replace","exports","module"],"mappings":"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","sourcesContent":["/*!\n * base64id v0.1.0\n */\n\n/**\n * Module dependencies\n */\n\nvar crypto = require('crypto');\n\n/**\n * Constructor\n */\n\nvar Base64Id = function() { };\n\n/**\n * Get random bytes\n *\n * Uses a buffer if available, falls back to crypto.randomBytes\n */\n\nBase64Id.prototype.getRandomBytes = function(bytes) {\n\n  var BUFFER_SIZE = 4096\n  var self = this;  \n  \n  bytes = bytes || 12;\n\n  if (bytes > BUFFER_SIZE) {\n    return crypto.randomBytes(bytes);\n  }\n  \n  var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);\n  var threshold = parseInt(bytesInBuffer*0.85);\n\n  if (!threshold) {\n    return crypto.randomBytes(bytes);\n  }\n\n  if (this.bytesBufferIndex == null) {\n     this.bytesBufferIndex = -1;\n  }\n\n  if (this.bytesBufferIndex == bytesInBuffer) {\n    this.bytesBuffer = null;\n    this.bytesBufferIndex = -1;\n  }\n\n  // No buffered bytes available or index above threshold\n  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {\n     \n    if (!this.isGeneratingBytes) {\n      this.isGeneratingBytes = true;\n      crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {\n        self.bytesBuffer = bytes;\n        self.bytesBufferIndex = 0;\n        self.isGeneratingBytes = false;\n      }); \n    }\n    \n    // Fall back to sync call when no buffered bytes are available\n    if (this.bytesBufferIndex == -1) {\n      return crypto.randomBytes(bytes);\n    }\n  }\n  \n  var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); \n  this.bytesBufferIndex++; \n  \n  return result;\n}\n\n/**\n * Generates a base64 id\n *\n * (Original version from socket.io <http://socket.io>)\n */\n\nBase64Id.prototype.generateId = function () {\n  var rand = Buffer.alloc(15); // multiple of 3 for base64\n  if (!rand.writeInt32BE) {\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()\n      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n  }\n  this.sequenceNumber = (this.sequenceNumber + 1) | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n  if (crypto.randomBytes) {\n    this.getRandomBytes(12).copy(rand);\n  } else {\n    // not secure for node 0.4\n    [0, 4, 8].forEach(function(i) {\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\n    });\n  }\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n\n/**\n * Export\n */\n\nexports = module.exports = new Base64Id();\n"]},"metadata":{},"sourceType":"script"}